import cantools
import can
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import random
import tkinter as tk
from tkinter import filedialog

# --- Browse for DBC and Log Files ---
root = tk.Tk()
root.withdraw()

print("Select DBC file:")
DBC_FILE = filedialog.askopenfilename(filetypes=[("DBC files", "*.dbc")])

print("Select CAN log file:")
CAN_LOG_FILE = filedialog.askopenfilename(filetypes=[("CAN log files", "*.log;*.blf;*.asc")])

# --- Load the DBC ---
db = cantools.database.load_file(DBC_FILE)

# --- Read CAN log ---
log = can.BLFReader(CAN_LOG_FILE) if CAN_LOG_FILE.endswith('.blf') else can.ASCReader(CAN_LOG_FILE)

# --- Prepare Visualization for each message ---
def random_color():
    return (random.random(), random.random(), random.random())

for frame in db.messages:
    # Find the first matching message in log
    message = None
    for msg in log:
        try:
            decoded = db.decode_message(msg.arbitration_id, msg.data)
            frame_from_log = db.get_message_by_frame_id(msg.arbitration_id)
            if frame_from_log.name == frame.name:
                message = msg
                break
        except Exception:
            continue

    if not message:
        continue

    signals = frame.signals

    # Create a bit array from the raw message data
    message_bits = []
    for byte in message.data:
        for i in range(8):
            message_bits.append((byte >> i) & 0x1)  # Little endian bit order

    signal_colors = {sig.name: random_color() for sig in signals}

    fig, ax = plt.subplots(figsize=(20, 4))
    ax.set_xlim(0, len(message_bits))
    ax.set_ylim(0, 1)
    ax.axis('off')

    # Draw all bits
    for bit_index in range(len(message_bits)):
        rect = patches.Rectangle((bit_index, 0), 1, 1, edgecolor='black', facecolor='white')
        ax.add_patch(rect)

    # Highlight each signal
    for sig in signals:
        start_bit = sig.start
        length = sig.length
        for i in range(length):
            bit_pos = start_bit - i if sig.byte_order == 'little_endian' else start_bit + i
            if 0 <= bit_pos < len(message_bits):
                rect = patches.Rectangle((bit_pos, 0), 1, 1, edgecolor='black', facecolor=signal_colors[sig.name])
                ax.add_patch(rect)

    # Label signals
    for sig in signals:
        start_bit = sig.start
        ax.text(start_bit + 0.5, 1.05, sig.name, rotation=90, fontsize=7, ha='center', va='bottom')

    plt.title(f'CAN Frame Layout: {frame.name}', fontsize=14)
    plt.tight_layout()
    plt.show()

    # Reset the log iterator for the next frame
    log = can.BLFReader(CAN_LOG_FILE) if CAN_LOG_FILE.endswith('.blf') else can.ASCReader(CAN_LOG_FILE)
